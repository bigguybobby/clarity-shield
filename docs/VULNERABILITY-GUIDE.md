# Clarity Vulnerability Guide

Comprehensive guide to security vulnerabilities in Clarity smart contracts.

## Table of Contents

1. [Authorization Vulnerabilities](#authorization-vulnerabilities)
2. [Error Handling Issues](#error-handling-issues)
3. [Arithmetic Safety](#arithmetic-safety)
4. [Data Validation](#data-validation)
5. [Centralization Risks](#centralization-risks)

---

## Authorization Vulnerabilities

### 1. Contract-Caller vs TX-Sender Confusion

**Severity**: üî¥ CRITICAL

#### The Issue

Clarity provides two principal identifiers:
- `tx-sender`: The original transaction signer
- `contract-caller`: The immediate calling contract

Using `contract-caller` for authorization can be bypassed by intermediate contracts.

#### Vulnerable Code

```clarity
(define-public (admin-function)
  (begin
    ;; ‚ùå WRONG: Anyone can call via malicious contract
    (asserts! (is-eq contract-caller ADMIN) (err u403))
    (perform-privileged-action)))
```

#### Attack Scenario

```clarity
;; Attacker deploys this contract
(define-public (exploit)
  (contract-call? .target-contract admin-function))
;; Now contract-caller is attacker's contract address
;; If attacker's contract address matches ADMIN, bypassed!
```

#### Secure Code

```clarity
(define-public (admin-function)
  (begin
    ;; ‚úÖ CORRECT: Check original signer
    (asserts! (is-eq tx-sender ADMIN) (err u403))
    (perform-privileged-action)))
```

#### When to Use Contract-Caller

Only use `contract-caller` when you explicitly want to authorize **contracts**, not users:

```clarity
;; Explicitly allowing specific contracts to call
(define-public (protocol-only-function)
  (begin
    (asserts! 
      (or 
        (is-eq contract-caller .vault-contract)
        (is-eq contract-caller .staking-contract))
      (err u403))
    (perform-action)))
```

---

### 2. Missing Authorization Checks

**Severity**: üü† HIGH

#### The Issue

Public functions that modify state without authorization checks allow any caller to execute privileged operations.

#### Vulnerable Code

```clarity
(define-public (mint (amount uint) (recipient principal))
  ;; ‚ùå Anyone can mint tokens!
  (ft-mint? token amount recipient))

(define-public (set-admin (new-admin principal))
  ;; ‚ùå Anyone can become admin!
  (ok (var-set admin new-admin)))
```

#### Secure Code

```clarity
(define-public (mint (amount uint) (recipient principal))
  (begin
    ;; ‚úÖ Only authorized minters
    (asserts! (is-eq tx-sender (var-get contract-owner)) ERR_UNAUTHORIZED)
    (ft-mint? token amount recipient)))

(define-public (set-admin (new-admin principal))
  (begin
    ;; ‚úÖ Only current admin can change admin
    (asserts! (is-eq tx-sender (var-get admin)) ERR_UNAUTHORIZED)
    (ok (var-set admin new-admin))))
```

#### Best Practices

1. **Default Deny**: Assume all public functions are unauthorized by default
2. **Explicit Checks**: Add `asserts!` with `tx-sender` validation
3. **Role-Based Access**: Use maps for complex permission systems:

```clarity
(define-map roles principal (list 10 (string-ascii 20)))

(define-private (has-role (account principal) (role (string-ascii 20)))
  (match (map-get? roles account)
    user-roles (is-some (index-of? user-roles role))
    false))
```

---

## Error Handling Issues

### 3. Unsafe Unwrap Operations

**Severity**: üü† HIGH

#### The Issue

`unwrap-panic` and `unwrap!` abort transactions when encountering `none` or `err` values, creating DoS vectors.

#### Vulnerable Code

```clarity
;; ‚ùå Panics if transfer fails
(define-public (force-transfer (amount uint) (recipient principal))
  (begin
    (unwrap-panic (stx-transfer? amount tx-sender recipient))
    (ok true)))

;; ‚ùå Throws error that might not be handled properly
(define-public (unsafe-unwrap (amount uint))
  (let ((balance (unwrap! (map-get? balances tx-sender) (err u404))))
    (ok balance)))
```

#### Attack Scenario

```clarity
;; Attacker can DoS by making transfer fail:
;; 1. Recipient is a contract with reject logic
;; 2. Insufficient balance edge cases
;; 3. Blacklisted addresses
```

#### Secure Code

```clarity
;; ‚úÖ Use match for explicit handling
(define-public (safe-transfer (amount uint) (recipient principal))
  (match (stx-transfer? amount tx-sender recipient)
    success (ok true)
    error (err error)))

;; ‚úÖ Use default-to for options
(define-public (safe-get-balance)
  (let ((balance (default-to u0 (map-get? balances tx-sender))))
    (ok balance)))

;; ‚úÖ Use try! to propagate errors
(define-public (propagate-errors (amount uint) (recipient principal))
  (begin
    (try! (stx-transfer? amount tx-sender recipient))
    (ok true)))
```

#### When Unwrap is OK

```clarity
;; ‚úÖ Acceptable in private functions with controlled input
(define-private (internal-helper)
  (let ((value (unwrap! (some u100) (err u0))))
    ;; Known to succeed
    value))
```

---

### 4. Unhandled Response Types

**Severity**: üü° MEDIUM

#### The Issue

Contract calls return `(response ok err)` types that must be handled. Ignoring responses leads to silent failures.

#### Vulnerable Code

```clarity
(define-public (call-external)
  (begin
    ;; ‚ùå Response ignored - silent failure
    (contract-call? .external-contract transfer u100 tx-sender)
    (ok true)))
```

#### Secure Code

```clarity
;; ‚úÖ Handle with try! (propagate)
(define-public (call-and-propagate)
  (begin
    (try! (contract-call? .external-contract transfer u100 tx-sender))
    (ok true)))

;; ‚úÖ Handle with match (explicit)
(define-public (call-and-handle)
  (match (contract-call? .external-contract transfer u100 tx-sender)
    success (ok success)
    error (err error)))
```

---

## Arithmetic Safety

### 5. Integer Overflow/Underflow

**Severity**: üü° MEDIUM

#### The Issue

Clarity's `uint` (u128) types wrap on overflow/underflow, potentially causing logic errors.

#### Vulnerable Code

```clarity
;; ‚ùå Can overflow if balance + amount > u128::MAX
(define-public (unsafe-add-balance (amount uint))
  (let ((new-balance (+ (get-balance tx-sender) amount)))
    (map-set balances tx-sender new-balance)
    (ok new-balance)))

;; ‚ùå Can underflow if balance < amount
(define-public (unsafe-subtract (amount uint))
  (let ((new-balance (- (get-balance tx-sender) amount)))
    (map-set balances tx-sender new-balance)
    (ok new-balance)))
```

#### Secure Code

```clarity
(define-constant u128-max u340282366920938463463374607431768211455)

;; ‚úÖ Check overflow
(define-public (safe-add-balance (amount uint))
  (let (
    (current (get-balance tx-sender))
    (new-balance (+ current amount))
  )
    (asserts! (<= new-balance u128-max) (err u1)) ;; overflow check
    (asserts! (>= new-balance current) (err u2))   ;; wrap check
    (map-set balances tx-sender new-balance)
    (ok new-balance)))

;; ‚úÖ Check underflow
(define-public (safe-subtract (amount uint))
  (let ((current (get-balance tx-sender)))
    (asserts! (>= current amount) (err u3)) ;; underflow check
    (map-set balances tx-sender (- current amount))
    (ok true)))
```

---

## Data Validation

### 6. Unsafe Data Map Access

**Severity**: üü° MEDIUM

#### The Issue

Setting map values without validating existing state can cause data inconsistencies.

#### Vulnerable Code

```clarity
;; ‚ùå Overwrites without checking
(define-public (set-balance (amount uint))
  (begin
    (map-set balances tx-sender amount)
    (ok true)))

;; ‚ùå No existence check
(define-public (unsafe-delete (user principal))
  (begin
    (map-delete balances user)
    (ok true)))
```

#### Secure Code

```clarity
;; ‚úÖ Validate before setting
(define-public (safe-set-balance (amount uint))
  (let ((current (default-to u0 (map-get? balances tx-sender))))
    (asserts! (> amount u0) (err u400))
    (map-set balances tx-sender amount)
    (ok true)))

;; ‚úÖ Check existence before delete
(define-public (safe-delete (user principal))
  (begin
    (asserts! (is-some (map-get? balances user)) (err u404))
    (map-delete balances user)
    (ok true)))
```

---

## Centralization Risks

### 7. Hardcoded Principals

**Severity**: ‚ö™ INFO

#### The Issue

Hardcoded addresses make contracts difficult to upgrade and create single points of failure.

#### Risky Code

```clarity
;; ‚ö†Ô∏è Hardcoded - can't be changed
(define-constant OWNER 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKNRV9EJ7)
```

#### Better Approach

```clarity
;; ‚úÖ Mutable with authorization
(define-data-var contract-owner principal tx-sender)

(define-public (transfer-ownership (new-owner principal))
  (begin
    (asserts! (is-eq tx-sender (var-get contract-owner)) ERR_UNAUTHORIZED)
    (ok (var-set contract-owner new-owner))))
```

---

## Summary Checklist

Use this checklist when writing Clarity contracts:

- [ ] Use `tx-sender` for user authorization, not `contract-caller`
- [ ] Add authorization checks to all public state-changing functions
- [ ] Avoid `unwrap-panic`; use `match`, `try!`, or `default-to`
- [ ] Handle all contract call responses explicitly
- [ ] Check for integer overflow/underflow on arithmetic
- [ ] Validate map state before setting/deleting
- [ ] Avoid hardcoded principals for administrative addresses
- [ ] Return proper error codes with `(err uint)` pattern
- [ ] Test with malicious input and edge cases
- [ ] Run Clarity Shield before deployment

---

**Happy auditing! üõ°Ô∏è**
